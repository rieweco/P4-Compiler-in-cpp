Storage=Local

clarification above needed per project turnin rules


*********************************************************
*         	      README FILE			*
*********************************************************

I used the LOCAL option for Variables
I am using vectors<string> to represent the semantics stack.
Everytime a variable is declared, it checks the vector for a declaration - 
	starting at the current scope, it will declare a new temp variable if 
	no matching identifier is found. If the identifier is found, it will 
	result in an error if it is in the same scope. 
	
	A vector is declared at the program start to be used to "global variables", 
	and a new vector is created and added to the original vector. This is how the 
	current scope is saved and searched.

	Labels work the exact same way as the temp variables. When a new loop is created, 
	a new label is made starting at L0. This way each loop has a unique label name. 

The program will parse input (from file or keyboard), generate a parse tree, perform 
	statis semantics, and then generate a target file ending in .asm.
	It also prints out to the screen the contents of the outfile before writing 
	to the outfile itself. 
There are multiple lines of code in the checkSem.cpp file that can be uncommented to see 
	the code Generated by specific nodes being parsed. I may add a verbose option to 
	enable that will display the contents of the nodes.

 	
*********************************************************
*		Program Based <BNF>:			*
*********************************************************

	<program>	-> 	program <vars> <block>
	<block>      	->      start <vars> <stats> stop
	<vars>          ->      empty | var Identifier = Integer <mvars> 
	<mvars>     	->     	.  | : Identifier <mvars>
	<expr>        	->      <M> + <expr> | <M> - <expr> | <M> / <expr> | <M> * <expr> | <M>
	<M>             ->     	% <M> |  <R>
	<R>             ->      ( <expr> ) | Identifier | Number   
	<stats>         ->      <stat>  <mStat>
	<mStat>       	->      empty |  <stat>  <mStat>
	<stat>          ->      <in> | <out> | <block> | <if> | <loop> | <assign>
	<in>            ->      read Identifier . 
	<out>           ->      print <expr>  .
	<if>            ->      iff ( <expr> <RO> <expr> ) <stat>
	<loop>          ->      iter ( <expr> <RO> <expr> ) <stat>
	<assign>       	->      let Identifier  = <expr>   .                                
	<RO>            ->      < | <  < | >  | >  > | =  =  |   =



*********************************************************
*		Instruction Set/Stack			*
*********************************************************
	
	BR 	(1, jump to arg)
	BRNEG 	(1, jump to arg if ACC <0)
	BRZNEG 	(1, jump to arg if ACC <=0)
	BRPOS 	(1, jump to arg if ACC >0)
	BRZPOS 	(1, jump to arg if ACC >=0)
	BRZERO 	(1, jump to arg if ACC ==0)
	COPY 	(2, arg1 = arg2)
	ADD 	(1, ACC = ACC +arg
	SUB 	(1, ACC = ACC - arg)
	DIV 	(1, ACC = ACC / arg)
	MULT 	(1, ACC = ACC * arg)
	READ 	(1, arg=input integer)
	WRITE 	(1, put arg to output as integer)
	STOP 	(0, stop program)
	STORE 	(1, arg = ACC)
	LOAD 	(1, ACC=arg)
	NOOP 	(0, nothing)
	PUSH 	(0, tos++)
	POP 	(0, tos--)    
	STACKW 	(1,stack[tos-arg]=ACC)
	STACKR 	(1,ACC=stack[tos-arg])
	


*********************************************************
*		Compilation Instructions		*
*********************************************************

TO COMPILE: make

OUTPUT: output file will end in .asm
	if keyboard input is used instead of using a file as input, 
	output file will be out.asm
	if file is used as input, 
	output file will be filename.asm 

TO RUN: ./comp [filename]

	filename is optional argument.
	files must end in .sp18
	if filename is test.sp18,
	it should be entered without .sp18

	ie. ./comp test


	if no argument is entered, keyboard
	input is read until Ctrl + D.
	Note: must end on a new line. 
	May have to press enter after pasting
	input into console.

	ie. ./comp
		paste in:
		program
			start
  			print 1 .
		stop

	must press Enter to go to new line 
	AFTER 'stop'

	Then you can press Ctrl-D to run program. 


*********************************************************
*		TO CLEAN UP EXECUTABLES			*
*********************************************************

TO REMOVE EXECUTABLES: make clean





*********************************************************
*	END OF README - THANK YOU FOR READING!		*
*********************************************************








